package foo;

import domix.Failure;
import io.vavr.control.Either;
import io.vavr.control.Try;
import lombok.NonNull;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import static foo.BeanValidatorUtil.orEmpty;
import static foo.BeanValidatorUtil.wrapFailure;

/**
 * Contract to perform Bean Validations and wrap the errors with {@link Failure}.
 * Concrete implementations should use something like Bean Validation 2.0 or Jakarta Bean Validation 3.0
 */
public interface BeanValidator<ConstraintViolation> {
  /**
   * Indicates the {@link Failure} was generated by a Bean Validation Violation.
   */
  String VALIDATION_CODE = "failure.validation";
  /**
   * Key used to get the localized message in a messages bundle.
   */
  String DEFAULT_VALIDATION_MESSAGE_KEY = "validation.error";
  String VALIDATION_EXPECTED_EXCEPTION_CODE = "failure.validation.unexpected.exception";

  /**
   * For the given {@code Object} applies the validation and return a non-empty {@link Optional<Failure>} if errors
   * are found.
   *
   * @param object the object to be validated
   * @param groups the given validations groups if needed
   * @return non-empty {@link Optional<Failure>} if errors found.
   */
  @Nonnull
  default <T> Optional<Failure> hasInvalidProperties(@Nonnull @NonNull final T object, @Nullable final Class<?>... groups) {
    return Try.of(() -> Optional.of(validate(object, groups)
          .stream()
          .map(this::failureDetail)
          .collect(Collectors.toList()))
        .filter(details -> !details.isEmpty())
        .map(details -> failure(object.getClass().getSimpleName(), details)))
      .getOrElseGet(throwable -> Optional.of(Failure.of(throwable, VALIDATION_EXPECTED_EXCEPTION_CODE)));
  }

  /**
   * Validates the given bean
   *
   * @param object the object to be validated
   * @param groups the given validations groups if needed
   * @param <T>    the under validation type class
   * @return Either a {@link Failure} if validation went wrong, the given object otherwise
   */
  @Nonnull
  default <T> Either<Failure, T> validateBean(@Nonnull @NonNull final T object, @Nullable final Class<?>... groups) {
    return hasInvalidProperties(object, groups)
      .map(failure -> wrapFailure(failure, object))
      .orElse(Either.right(object));
  }

  /**
   * Maps the given {@code ConstraintViolation} to {@link Failure.Detail}
   *
   * @param constraintViolation the given {@code ConstraintViolation}
   * @return a new {@code Failure.Detail}
   */
  @Nonnull
  default Failure.Detail failureDetail(@Nonnull @NonNull final ConstraintViolation constraintViolation) {
    return Failure.ofValidationError(
      orEmpty(getMessageCode(constraintViolation)),
      orEmpty(getLocalizedMessage(constraintViolation)),
      orEmpty(getPropertyPath(constraintViolation))
    );
  }

  /**
   * Build a {@link Failure} for the given details
   *
   * @param className the bean's simple class name with errors
   * @param details   the given error details
   * @return A new {@link Failure}
   */
  @Nonnull
  default Failure failure(@Nonnull @NonNull final String className, @Nonnull @NonNull final List<Failure.Detail> details) {
    final var reason = "Class '%s' has invalid property values".formatted(className);
    final var i18nData = Failure.I18nData.builder()
      .code(DEFAULT_VALIDATION_MESSAGE_KEY)
      .defaultMessage(reason)
      .build();
    return Failure.builder()
      .code(VALIDATION_CODE)
      .details(details)
      .i18nData(i18nData)
      .reason(reason)
      .build();
  }

  /**
   * Perform the bean validation for the given Object and given validation groups.
   *
   * @param object the object to be validated
   * @param groups the given validations groups if needed
   * @return constraint violations or an empty set if none
   */
  @Nonnull
  <T> Set<ConstraintViolation> validate(@Nonnull final T object, @Nullable final Class<?>... groups);

  /**
   * For the given {@code ConstraintViolation} gets the message code
   *
   * @param constraintViolation the given {@code ConstraintViolation}
   * @return the message code
   */
  @Nullable
  String getMessageCode(@Nonnull ConstraintViolation constraintViolation);

  /**
   * For the given {@code ConstraintViolation} gets the localized message
   *
   * @param constraintViolation the given {@code ConstraintViolation}
   * @return the localized message
   */
  @Nullable
  String getLocalizedMessage(@Nonnull ConstraintViolation constraintViolation);

  /**
   * For the given {@code ConstraintViolation} gets the property path
   *
   * @param constraintViolation the given {@code ConstraintViolation}
   * @return the property path
   */
  @Nullable
  String getPropertyPath(@Nonnull ConstraintViolation constraintViolation);

}

